package main

import (
	"bytes"
	"embed"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strings"

	"github.com/benekuehn/socle/cli/so/cmd" // Adjusted import path relative to go.mod
	"github.com/spf13/cobra/doc"
)

// Embed a file within the package to help locate the package directory.
// Create an empty file named .embed in the same directory as main.go
//
//go:embed .embed
var embedMarker embed.FS

const (
	startMarker         = "<!-- CLI_REFERENCE_START -->"
	endMarker           = "<!-- CLI_REFERENCE_END -->"
	generatedDocsHeader = "## CLI Command Reference"                                // Keep this header
	autoGenNotice       = "*This section is auto-generated. Do not edit manually.*" // Keep this notice
)

// cleanMarkdown removes boilerplate and reformats Cobra's generated Markdown.
func cleanMarkdown(content []byte, isRoot bool) []byte {
	// Regex to capture the main command heading text (e.g., "so create") and the synopsis content,
	// skipping the short description line and the "### Synopsis" header.
	// (?s) dot matches newline. Group 1: Command name part. Group 2: Synopsis Content.
	reFormat := regexp.MustCompile(`(?s)^## (.*?)\n\n(?:.*?\n)\n### Synopsis\n\n(.*?)(?:$|\n\n### Options|\n\n### SEE ALSO)`) // $ matches end of input

	// Apply the main reformatting first
	// Replace with ### Heading Text + newline + Synopsis Content
	cleaned := reFormat.ReplaceAll(content, []byte("### $1\n$2"))

	// Now remove other boilerplate from the potentially reformatted content
	reSeeAlso := regexp.MustCompile(`(?s)### SEE ALSO.*`)
	cleaned = reSeeAlso.ReplaceAll(cleaned, []byte(""))

	// Remove Auto generated footer
	reFooter := regexp.MustCompile(`(?s)###### Auto generated by spf13/cobra on.*`)
	cleaned = reFooter.ReplaceAll(cleaned, []byte(""))

	// Change "### Options" to "#### Options"
	// Use (?m) for multiline mode so ^ matches the beginning of a line
	reOptions := regexp.MustCompile(`(?m)^### Options$`)
	cleaned = reOptions.ReplaceAll(cleaned, []byte("#### Options"))

	// Trim leading/trailing whitespace from the final result
	cleaned = bytes.TrimSpace(cleaned)

	return cleaned
}

func main() {
	// Determine the absolute path to the docgen directory using the embed marker
	// docgenDir := "." // Default to current dir as fallback - REMOVED
	files, err := embedMarker.ReadDir(".")
	if err == nil && len(files) > 0 {
		// This is a trick: ReadDir gives info relative to the embedded FS root.
		// To get the *actual* system path, we often need to work backwards or make assumptions.
		// A common approach for tools run via `go run` is to rely on the working directory
		// or require the script to be run from a specific location.
		// Let's try finding the module root and constructing the path from there.

		// Find module root by looking for go.mod upwards from current dir
		wd, errWd := os.Getwd()
		if errWd != nil {
			log.Fatalf("Could not get working directory: %v", errWd)
		}
		modRoot := findModRoot(wd)
		if modRoot == "" {
			log.Fatalf("Could not find go.mod in parent directories of %s", wd)
		}
		// Construct path from module root
		readmePath := filepath.Join(modRoot, "README.md")
		log.Printf("Calculated README path relative to module root: %s", readmePath)

		// --- Step 1: Generate Markdown to a temporary directory ---
		rootCmd := cmd.GetRootCmd()
		tempDir, err := os.MkdirTemp("", "socle-docgen-")
		if err != nil {
			log.Fatalf("Failed to create temporary directory: %v", err)
		}
		defer func() { _ = os.RemoveAll(tempDir) }() // Clean up the temp directory

		log.Printf("Generating Markdown documentation in temporary directory %s", tempDir)

		// Generate the documentation files (without front matter as we combine them)
		err = doc.GenMarkdownTree(rootCmd, tempDir)
		if err != nil {
			log.Fatalf("Failed to generate Markdown documentation tree: %v", err)
		}

		// --- Step 2: Read, Clean, and Combine Generated Files ---
		var combinedDocs bytes.Buffer
		files, err := os.ReadDir(tempDir)
		if err != nil {
			log.Fatalf("Failed to read temporary directory %s: %v", tempDir, err)
		}

		// Sort files (root first, then alphabetically)
		sort.Slice(files, func(i, j int) bool {
			rootFileName := rootCmd.Name() + ".md"
			if files[i].Name() == rootFileName {
				return true
			}
			if files[j].Name() == rootFileName {
				return false
			}
			return files[i].Name() < files[j].Name()
		})

		firstCommandAdded := false // Track if we've added the first *subcommand*
		for _, file := range files {
			if !file.IsDir() && strings.HasSuffix(file.Name(), ".md") {
				// Skip the root command file itself
				rootFileName := rootCmd.Name() + ".md"
				if file.Name() == rootFileName {
					log.Printf("Skipping root command file: %s", file.Name())
					continue // Skip to the next file
				}

				filePath := filepath.Join(tempDir, file.Name())
				content, err := os.ReadFile(filePath)
				if err != nil {
					log.Printf("Warning: Failed to read generated file %s: %v", filePath, err)
					continue
				}

				// Clean the Markdown content (isRoot is now always false here)
				cleanedContent := cleanMarkdown(content, false)

				// Add separator (horizontal rule) between commands, but not before the first *included* one
				if firstCommandAdded { // Add separator *before* adding the next command
					combinedDocs.WriteString("\n\n---\n\n")
				} else {
					firstCommandAdded = true // Mark that we've added the first subcommand
				}

				combinedDocs.Write(cleanedContent)
				log.Printf("Read, cleaned, and combined %s", file.Name())
			}
		}

		// --- Step 3: Read README.md ---
		log.Printf("Reading target README file: %s", readmePath)
		readmeContent, err := os.ReadFile(readmePath)
		if err != nil {
			log.Fatalf("Failed to read README file %s: %v", readmePath, err)
		}

		// --- Step 4: Find Markers and Inject Content ---
		startIdx := bytes.Index(readmeContent, []byte(startMarker))
		endIdx := bytes.Index(readmeContent, []byte(endMarker))

		if startIdx == -1 || endIdx == -1 || endIdx <= startIdx {
			log.Fatalf("Could not find markers '%s' and '%s' in %s", startMarker, endMarker, readmePath)
		}

		// Construct the final content to inject
		var finalContent bytes.Buffer
		finalContent.WriteString(startMarker + "\n")     // Keep start marker
		finalContent.WriteString(autoGenNotice + "\n\n") // Add notice
		finalContent.Write(combinedDocs.Bytes())         // Add combined docs
		finalContent.WriteString("\n" + endMarker)       // Keep end marker

		// Replace the content between markers
		var newReadmeContent bytes.Buffer
		newReadmeContent.Write(readmeContent[:startIdx])
		newReadmeContent.Write(finalContent.Bytes())
		newReadmeContent.Write(readmeContent[endIdx+len(endMarker):])

		// --- Step 5: Write Updated README.md ---
		log.Printf("Writing updated content back to %s", readmePath)
		err = os.WriteFile(readmePath, newReadmeContent.Bytes(), 0644)
		if err != nil {
			log.Fatalf("Failed to write updated README file %s: %v", readmePath, err)
		}

		log.Println("README.md updated successfully with CLI reference.")

	} else {
		log.Fatalf("Could not use embed marker to determine path context: %v", err)
	}
}

// findModRoot searches upwards from startDir for a directory containing go.mod
func findModRoot(startDir string) string {
	dir := startDir
	for {
		goModPath := filepath.Join(dir, "go.mod")
		if _, err := os.Stat(goModPath); err == nil {
			// Found go.mod
			return dir
		}
		// Move up one directory
		parent := filepath.Dir(dir)
		if parent == dir {
			// Reached root directory
			return ""
		}
		dir = parent
	}
}
